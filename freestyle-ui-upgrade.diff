diff --git a/release/scripts/presets/linestyle/Brush.py b/release/scripts/presets/linestyle/Brush.py
new file mode 100644
index 00000000000..3873b206d10
--- /dev/null
+++ b/release/scripts/presets/linestyle/Brush.py
@@ -0,0 +1,17 @@
+import bpy
+from mathutils import Vector
+
+linestyle = bpy.data.linestyles.new(name="Brush")
+
+mod1 = linestyle.thickness_modifiers.new(
+    name="Along Stroke", type='ALONG_STROKE')
+mod1.mapping = 'CURVE'
+mod1.value_min = 2.0
+mod1.value_max = 10.0
+mod1.curve.curves[0].points[1].location = Vector((1., 0.))
+mod1.curve.curves[0].points.new(0.5, 1.0)
+mod1.curve.update()
+
+linestyle.geometry_modifiers.new(name="Bezier Curve", type="BEZIER_CURVE")
+
+bpy.context.view_layer.freestyle_settings.linesets.active.linestyle = linestyle
diff --git a/release/scripts/presets/linestyle/Doodle.py b/release/scripts/presets/linestyle/Doodle.py
new file mode 100644
index 00000000000..266563424d5
--- /dev/null
+++ b/release/scripts/presets/linestyle/Doodle.py
@@ -0,0 +1,24 @@
+import bpy
+from mathutils import Vector
+
+linestyle = bpy.data.linestyles.new(name="Doodle")
+linestyle.chaining = 'SKETCHY'
+linestyle.use_same_object = False
+
+linestyle.alpha = 0.910714
+linestyle.thickness = 2.0
+
+linestyle.geometry_modifiers["Sampling"].sampling = 2.0
+
+mod1 = linestyle.geometry_modifiers.new(name="2D Offset", type='2D_OFFSET')
+mod1.start = 5.0
+mod1.end = 2.0
+mod1.x = -0.1
+mod1.y = 0.2
+
+mod2 = linestyle.geometry_modifiers.new(
+    name="Spatial Noise", type='SPATIAL_NOISE')
+mod2.amplitude = 1.5
+mod2.scale = 10.0
+
+bpy.context.view_layer.freestyle_settings.linesets.active.linestyle = linestyle
diff --git a/release/scripts/presets/linestyle/Generic_Tapered.py b/release/scripts/presets/linestyle/Generic_Tapered.py
new file mode 100644
index 00000000000..48704537130
--- /dev/null
+++ b/release/scripts/presets/linestyle/Generic_Tapered.py
@@ -0,0 +1,20 @@
+import bpy
+from mathutils import Vector, Color
+
+linestyle = bpy.data.linestyles.new(name="Generic Tapered")
+linestyle.geometry_modifiers['Sampling'].sampling = 1.0
+
+mod1 = linestyle.thickness_modifiers.new(
+    name="Along Stroke", type='ALONG_STROKE')
+mod1.mapping = 'CURVE'
+mod1.value_min = 1.0
+mod1.value_max = 3.0
+mod1.curve.curves[0].points[1].location = Vector((1., 0.))
+mod1.curve.curves[0].points.new(0.5, 1.0)
+mod1.curve.update()
+
+mod2 = linestyle.geometry_modifiers.new(
+    name="Bezier Curve", type='BEZIER_CURVE')
+mod2.error = 1.0
+
+bpy.context.view_layer.freestyle_settings.linesets.active.linestyle = linestyle
diff --git a/release/scripts/presets/linestyle/Invisible_Lines.py b/release/scripts/presets/linestyle/Invisible_Lines.py
new file mode 100644
index 00000000000..2ea49b1a468
--- /dev/null
+++ b/release/scripts/presets/linestyle/Invisible_Lines.py
@@ -0,0 +1,10 @@
+import bpy
+from mathutils import Vector, Color
+
+linestyle = bpy.data.linestyles.new(name="Invisible Lines")
+linestyle.caps = 'ROUND'
+linestyle.use_dashed_line = True
+linestyle.dash1 = 8
+linestyle.gap1 = 5
+
+bpy.context.view_layer.freestyle_settings.linesets.active.linestyle = linestyle
diff --git a/release/scripts/presets/linestyle/Noisy.py b/release/scripts/presets/linestyle/Noisy.py
new file mode 100644
index 00000000000..9f416409178
--- /dev/null
+++ b/release/scripts/presets/linestyle/Noisy.py
@@ -0,0 +1,22 @@
+import bpy
+from mathutils import Vector, Color
+
+linestyle = bpy.data.linestyles.new(name="Noisy")
+linestyle.use_chaining = False
+
+linestyle.use_split_pattern = True
+linestyle.split_dash1 = 4
+linestyle.split_gap1 = 4
+
+linestyle.use_dashed_line = True
+linestyle.dash1 = 4
+linestyle.gap1 = 4
+
+linestyle.geometry_modifiers['Sampling'].sampling = 1.0
+
+mod1 = linestyle.geometry_modifiers.new(name="Blueprint", type="BLUEPRINT")
+mod1.shape = 'SQUARES'
+mod1.backbone_length = 0.0
+mod1.random_backbone = 2
+
+bpy.context.view_layer.freestyle_settings.linesets.active.linestyle = linestyle
diff --git a/release/scripts/presets/linestyle/Pen.py b/release/scripts/presets/linestyle/Pen.py
new file mode 100644
index 00000000000..3f2a1055ce6
--- /dev/null
+++ b/release/scripts/presets/linestyle/Pen.py
@@ -0,0 +1,19 @@
+import bpy
+from mathutils import Vector, Color
+
+linestyle = bpy.data.linestyles.new(name="Pen")
+linestyle.caps = 'ROUND'
+linestyle.chaining = 'SKETCHY'
+linestyle.rounds = 2
+linestyle.color = Color((0.002428, 0.016807, 0.06301))
+
+mod1 = linestyle.thickness_modifiers.new(
+    name="Calligraphy", type="CALLIGRAPHY")
+mod1.thickness_max = 5.0
+
+linestyle.geometry_modifiers['Sampling'].sampling = 1.0
+
+linestyle.geometry_modifiers.new(name="Bezier Curve", type="BEZIER_CURVE")
+linestyle.geometry_modifiers.new(name="Tip Remover", type="TIP_REMOVER")
+
+bpy.context.view_layer.freestyle_settings.linesets.active.linestyle = linestyle
diff --git a/release/scripts/presets/linestyle/Pencil.py b/release/scripts/presets/linestyle/Pencil.py
new file mode 100644
index 00000000000..d7a4dfa36d6
--- /dev/null
+++ b/release/scripts/presets/linestyle/Pencil.py
@@ -0,0 +1,26 @@
+import bpy
+from mathutils import Vector
+
+linestyle = bpy.data.linestyles.new(name="Pencil")
+linestyle.caps = 'ROUND'
+linestyle.chaining = 'SKETCHY'
+linestyle.rounds = 2
+linestyle.alpha = 0.9
+
+mod1 = linestyle.thickness_modifiers.new(
+    name="Along Stroke", type='ALONG_STROKE')
+mod1.mapping = 'CURVE'
+mod1.value_min = 2.0
+mod1.value_max = 3.0
+mod1.curve.curves[0].points[1].location = Vector((1., 0.))
+mod1.curve.curves[0].points.new(0.5, 1.0)
+mod1.curve.update()
+
+linestyle.geometry_modifiers['Sampling'].sampling = 1.0
+
+mod2 = linestyle.geometry_modifiers.new(
+    name="Perlin Noise 2D", type='PERLIN_NOISE_2D')
+mod2.frequency = 10.0
+mod2.amplitude = 0.8
+
+bpy.context.view_layer.freestyle_settings.linesets.active.linestyle = linestyle
diff --git a/release/scripts/presets/linestyle/Thick_Joins.py b/release/scripts/presets/linestyle/Thick_Joins.py
new file mode 100644
index 00000000000..bff844f2aad
--- /dev/null
+++ b/release/scripts/presets/linestyle/Thick_Joins.py
@@ -0,0 +1,21 @@
+import bpy
+from mathutils import Vector
+
+linestyle = bpy.data.linestyles.new(name="Thick Joins")
+linestyle.caps = 'ROUND'
+linestyle.use_chaining = False
+
+mod1 = linestyle.thickness_modifiers.new(
+    name="Along Stroke", type='ALONG_STROKE')
+mod1.mapping = 'CURVE'
+mod1.value_min = 2.0
+mod1.value_max = 5.0
+
+mod1.curve.curves[0].points[0].location = Vector((0., 1.))
+mod1.curve.curves[0].points[1].location = Vector((1., 1.))
+mod1.curve.curves[0].points.new(0.1, 0.5)
+mod1.curve.curves[0].points.new(0.5, 0.0)
+mod1.curve.curves[0].points.new(0.9, 0.5)
+mod1.curve.update()
+
+bpy.context.view_layer.freestyle_settings.linesets.active.linestyle = linestyle
diff --git a/release/scripts/startup/bl_ui/properties_freestyle.py b/release/scripts/startup/bl_ui/properties_freestyle.py
index fd12747e2fa..9357e74ff2b 100644
--- a/release/scripts/startup/bl_ui/properties_freestyle.py
+++ b/release/scripts/startup/bl_ui/properties_freestyle.py
@@ -19,14 +19,20 @@
 # <pep8 compliant>
 import bpy
 from bpy.types import Menu, Panel, UIList
+from bl_ui.utils import PresetPanel
 
 
+class VIEWLAYER_PT_linestyle_presets(PresetPanel, Panel):
+    bl_label = "LineStyle Presets"
+    preset_subdir = "linestyle"
+    preset_operator = "script.python_file_run"
+
 # Render properties
 
 class RenderFreestyleButtonsPanel:
     bl_space_type = 'PROPERTIES'
     bl_region_type = 'WINDOW'
-    bl_context = "render"
+    bl_context = "view_layer"
     # COMPAT_ENGINES must be defined in each subclass, external engines can add themselves here
 
     @classmethod
@@ -37,7 +43,8 @@ class RenderFreestyleButtonsPanel:
 
 
 class RENDER_PT_freestyle(RenderFreestyleButtonsPanel, Panel):
-    bl_label = "Freestyle"
+    bl_label = "Render Freestyle"
+    bl_parent_id = "VIEWLAYER_PT_layer"
     bl_options = {'DEFAULT_CLOSED'}
     bl_order = 10
     COMPAT_ENGINES = {'BLENDER_RENDER', 'BLENDER_EEVEE', 'BLENDER_WORKBENCH'}
@@ -51,11 +58,15 @@ class RENDER_PT_freestyle(RenderFreestyleButtonsPanel, Panel):
         layout.use_property_split = True
         layout.use_property_decorate = False  # No animation.
 
+        ui_factor = context.region.width / bpy.context.preferences.system.dpi
+        is_narrow = ui_factor < 3
+
         rd = context.scene.render
 
         layout.active = rd.use_freestyle
 
-        layout.prop(rd, "line_thickness_mode", expand=True)
+        flow = layout.column() if is_narrow else layout.row()
+        flow.prop(rd, "line_thickness_mode", expand=True)
 
         if rd.line_thickness_mode == 'ABSOLUTE':
             layout.prop(rd, "line_thickness")
@@ -88,14 +99,55 @@ class ViewLayerFreestyleEditorButtonsPanel(ViewLayerFreestyleButtonsPanel):
         if not super().poll(context):
             return False
         view_layer = context.view_layer
-        return view_layer and view_layer.freestyle_settings.mode == 'EDITOR'
+        return view_layer and view_layer.use_freestyle and view_layer.freestyle_settings.mode == 'EDITOR'
+
+
+class ViewLayerFreestyleLinesetSubPanel(ViewLayerFreestyleEditorButtonsPanel):
+    # Freestyle Lineset sub panles
+    bl_parent_id = "VIEWLAYER_PT_freestyle_lineset"
+    COMPAT_ENGINES = {'BLENDER_RENDER', 'BLENDER_EEVEE', 'BLENDER_WORKBENCH'}
+
+    @classmethod
+    def poll(cls, context):
+        if not super().poll(context):
+            return False
+        view_layer = context.view_layer
+        lineset = view_layer.freestyle_settings.linesets.active
+        if lineset is None:
+            return False
+        return True
+
+
+class ViewLayerFreestyleLineStyle(ViewLayerFreestyleEditorButtonsPanel):
+    # Freestyle Linestyle Panels
+    COMPAT_ENGINES = {'BLENDER_RENDER', 'BLENDER_EEVEE', 'BLENDER_WORKBENCH'}
+
+    @classmethod
+    def poll(cls, context):
+        if not super().poll(context):
+            return False
+        view_layer = context.view_layer
+        lineset = view_layer.freestyle_settings.linesets.active
+        if lineset is None:
+            return False
+        linestyle = lineset.linestyle
+        if linestyle is None:
+            return False
+
+        return True
+
+
+class ViewLayerFreestyleLinestyleStrokesSubPanel(ViewLayerFreestyleLineStyle):
+    # Freestyle Linestyle Strokes sub panels
+    bl_parent_id = "VIEWLAYER_PT_freestyle_linestyle_strokes"
 
 
 class VIEWLAYER_UL_linesets(UIList):
     def draw_item(self, _context, layout, _data, item, icon, _active_data, _active_propname, index):
         lineset = item
         if self.layout_type in {'DEFAULT', 'COMPACT'}:
-            layout.prop(lineset, "name", text="", emboss=False, icon_value=icon)
+            layout.prop(lineset, "name", text="",
+                        emboss=False, icon_value=icon)
             layout.prop(lineset, "show_render", text="", index=index)
         elif self.layout_type == 'GRID':
             layout.alignment = 'CENTER'
@@ -126,54 +178,61 @@ class VIEWLAYER_PT_freestyle(ViewLayerFreestyleButtonsPanel, Panel):
 
     def draw(self, context):
         layout = self.layout
+        layout.use_property_split = True
+        layout.use_property_decorate = False
 
         view_layer = context.view_layer
         freestyle = view_layer.freestyle_settings
 
         layout.active = view_layer.use_freestyle
 
-        row = layout.row()
-        layout.prop(freestyle, "mode", text="Control Mode")
-        layout.prop(freestyle, "use_view_map_cache", text="View Map Cache")
-        layout.prop(freestyle, "as_render_pass", text="As Render Pass")
-        layout.label(text="Edge Detection Options:")
+        col = layout.column(align=True)
+        col.prop(freestyle, "mode", text="Control Mode")
+        col.prop(freestyle, "use_view_map_cache", text="View Map Cache")
+        col.prop(freestyle, "as_render_pass", text="As Render Pass")
 
-        split = layout.split()
+        split = layout.split(factor=.4)
+        split.alignment = 'RIGHT'
+        split.label(text="Edge Detection Options")
 
-        col = split.column()
+        col = layout.column()
         col.prop(freestyle, "crease_angle")
         col.prop(freestyle, "use_culling")
-        col.prop(freestyle, "use_advanced_options")
-
-        col = split.column()
         col.prop(freestyle, "use_smoothness")
+
         if freestyle.mode == 'SCRIPT':
             col.prop(freestyle, "use_material_boundaries")
 
+        col.prop(freestyle, "use_advanced_options")
+
         # Advanced options are hidden by default to warn new users
         if freestyle.use_advanced_options:
             if freestyle.mode == 'SCRIPT':
-                row = layout.row()
-                row.prop(freestyle, "use_ridges_and_valleys")
-                row.prop(freestyle, "use_suggestive_contours")
-            row = layout.row()
-            row.prop(freestyle, "sphere_radius")
-            row.prop(freestyle, "kr_derivative_epsilon")
+                col.prop(freestyle, "use_ridges_and_valleys")
+                col.prop(freestyle, "use_suggestive_contours")
+            col.prop(freestyle, "sphere_radius")
+            col.prop(freestyle, "kr_derivative_epsilon")
 
         if freestyle.mode == 'SCRIPT':
-            row = layout.row()
+            col = layout.column()
+            col.use_property_split = False
+            row = col.row()
             row.label(text="Style Modules:")
             row.operator("scene.freestyle_module_add", text="Add")
             for module in freestyle.modules:
-                box = layout.box()
+                box = col.box()
                 box.context_pointer_set("freestyle_module", module)
                 row = box.row(align=True)
                 row.prop(module, "use", text="")
                 row.prop(module, "script", text="")
-                row.operator("scene.freestyle_module_open", icon='FILEBROWSER', text="")
-                row.operator("scene.freestyle_module_remove", icon='X', text="")
-                row.operator("scene.freestyle_module_move", icon='TRIA_UP', text="").direction = 'UP'
-                row.operator("scene.freestyle_module_move", icon='TRIA_DOWN', text="").direction = 'DOWN'
+                row.operator("scene.freestyle_module_open",
+                             icon='FILEBROWSER', text="")
+                row.operator("scene.freestyle_module_remove",
+                             icon='X', text="")
+                row.operator("scene.freestyle_module_move",
+                             icon='TRIA_UP', text="").direction = 'UP'
+                row.operator("scene.freestyle_module_move",
+                             icon='TRIA_DOWN', text="").direction = 'DOWN'
 
 
 class VIEWLAYER_PT_freestyle_lineset(ViewLayerFreestyleEditorButtonsPanel, Panel):
@@ -199,7 +258,6 @@ class VIEWLAYER_PT_freestyle_lineset(ViewLayerFreestyleEditorButtonsPanel, Panel
         lineset = freestyle.linesets.active
 
         layout.active = view_layer.use_freestyle
-
         row = layout.row()
         rows = 4 if lineset else 2
         row.template_list(
@@ -215,146 +273,562 @@ class VIEWLAYER_PT_freestyle_lineset(ViewLayerFreestyleEditorButtonsPanel, Panel
         sub = row.column(align=True)
         sub.operator("scene.freestyle_lineset_add", icon='ADD', text="")
         sub.operator("scene.freestyle_lineset_remove", icon='REMOVE', text="")
-        sub.menu("RENDER_MT_lineset_context_menu", icon='DOWNARROW_HLT', text="")
+        sub.menu("RENDER_MT_lineset_context_menu",
+                 icon='DOWNARROW_HLT', text="")
         if lineset:
             sub.separator()
             sub.separator()
-            sub.operator("scene.freestyle_lineset_move", icon='TRIA_UP', text="").direction = 'UP'
-            sub.operator("scene.freestyle_lineset_move", icon='TRIA_DOWN', text="").direction = 'DOWN'
+            sub.operator("scene.freestyle_lineset_move",
+                         icon='TRIA_UP', text="").direction = 'UP'
+            sub.operator("scene.freestyle_lineset_move",
+                         icon='TRIA_DOWN', text="").direction = 'DOWN'
 
             col = layout.column()
             col.label(text="Selection By:")
             row = col.row(align=True)
-            row.prop(lineset, "select_by_visibility", text="Visibility", toggle=True)
-            row.prop(lineset, "select_by_edge_types", text="Edge Types", toggle=True)
-            row.prop(lineset, "select_by_face_marks", text="Face Marks", toggle=True)
-            row.prop(lineset, "select_by_collection", text="Collection", toggle=True)
-            row.prop(lineset, "select_by_image_border", text="Image Border", toggle=True)
-
-            if lineset.select_by_visibility:
-                col.label(text="Visibility:")
-                row = col.row(align=True)
-                row.prop(lineset, "visibility", expand=True)
-                if lineset.visibility == 'RANGE':
-                    row = col.row(align=True)
-                    row.prop(lineset, "qi_start")
-                    row.prop(lineset, "qi_end")
-
-            if lineset.select_by_edge_types:
-                col.label(text="Edge Types:")
-                row = col.row()
-                row.prop(lineset, "edge_type_negation", expand=True)
-                row.prop(lineset, "edge_type_combination", expand=True)
-
-                split = col.split()
-
-                sub = split.column()
-                self.draw_edge_type_buttons(sub, lineset, "silhouette")
-                self.draw_edge_type_buttons(sub, lineset, "border")
-                self.draw_edge_type_buttons(sub, lineset, "contour")
-                self.draw_edge_type_buttons(sub, lineset, "suggestive_contour")
-                self.draw_edge_type_buttons(sub, lineset, "ridge_valley")
-
-                sub = split.column()
-                self.draw_edge_type_buttons(sub, lineset, "crease")
-                self.draw_edge_type_buttons(sub, lineset, "edge_mark")
-                self.draw_edge_type_buttons(sub, lineset, "external_contour")
-                self.draw_edge_type_buttons(sub, lineset, "material_boundary")
-
-            if lineset.select_by_face_marks:
-                col.label(text="Face Marks:")
-                row = col.row()
-                row.prop(lineset, "face_mark_negation", expand=True)
-                row.prop(lineset, "face_mark_condition", expand=True)
-
-            if lineset.select_by_collection:
-                col.label(text="Collection:")
-                row = col.row()
-                row.prop(lineset, "collection", text="")
-                row.prop(lineset, "collection_negation", expand=True)
-
-
-class VIEWLAYER_PT_freestyle_linestyle(ViewLayerFreestyleEditorButtonsPanel, Panel):
+            row.separator(factor=2.0)
+            row.prop(lineset, "select_by_image_border", text="Image Border")
+
+
+# Freestyle Lineset Sub Panels
+class VIEWLAYER_PT_freestyle_lineset_visibilty(ViewLayerFreestyleLinesetSubPanel, Panel):
+    bl_label = "Visibility"
+
+    def draw_header(self, context):
+        layout = self.layout
+
+        view_layer = context.view_layer
+        freestyle = view_layer.freestyle_settings
+        lineset = freestyle.linesets.active
+
+        layout.prop(lineset, "select_by_visibility", text="")
+
+    def draw(self, context):
+        layout = self.layout
+        layout.use_property_split = True
+        layout.use_property_decorate = False
+
+        # a solution for dynamic UI (e.g column if space is narrow, else row)
+        # because grid flow doesn't adapt well with property split
+        ui_factor = context.region.width / bpy.context.preferences.system.dpi
+        is_narrow = ui_factor < 3
+
+        view_layer = context.view_layer
+        freestyle = view_layer.freestyle_settings
+        lineset = freestyle.linesets.active
+
+        layout.active = lineset.select_by_visibility
+
+        split = layout.split(factor=.4)
+        split.alignment = "RIGHT"
+        split.label(text="Type")
+
+        col = split.column(align=True)
+        col.use_property_split = False
+        col.prop(lineset, "visibility", text="Type", expand=True)
+
+        if lineset.visibility == 'RANGE':
+            split = layout.split(factor=.4)
+            split.alignment = "RIGHT"
+            split.label(text="QI Range")
+
+            flow = split.column(
+                align=True) if is_narrow else split.row(align=True)
+            flow.use_property_split = False
+            flow.prop(lineset, "qi_start")
+            flow.prop(lineset, "qi_end")
+
+
+class VIEWLAYER_PT_freestyle_lineset_edgetypes(ViewLayerFreestyleLinesetSubPanel, Panel):
+    bl_label = "Edge Types"
+
+    def draw_header(self, context):
+        layout = self.layout
+
+        view_layer = context.view_layer
+        freestyle = view_layer.freestyle_settings
+        lineset = freestyle.linesets.active
+
+        layout.prop(lineset, "select_by_edge_types", text="")
+
+    def draw_edge_type_buttons(self, box, lineset, edge_type):
+        # property names
+        select_edge_type = "select_" + edge_type
+        exclude_edge_type = "exclude_" + edge_type
+        # draw edge type buttons
+        row = box.row(align=True)
+        row.prop(lineset, select_edge_type)
+        sub = row.column(align=True)
+        sub.prop(lineset, exclude_edge_type, text="")
+        sub.active = getattr(lineset, select_edge_type)
+
+    def draw(self, context):
+        layout = self.layout
+        layout.use_property_split = True
+        layout.use_property_decorate = False
+
+        ui_factor = context.region.width / bpy.context.preferences.system.dpi
+        is_narrow = ui_factor < 3
+
+        view_layer = context.view_layer
+        freestyle = view_layer.freestyle_settings
+        lineset = freestyle.linesets.active
+
+        if lineset is None:
+            return False
+
+        layout.active = lineset.select_by_edge_types
+
+        flow = layout.column() if is_narrow else layout.row()
+        flow.prop(lineset, "edge_type_negation", expand=True, text="Negation")
+
+        flow = layout.column() if is_narrow else layout.row()
+        flow.prop(lineset, "edge_type_combination",
+                  expand=True, text="Combination")
+
+        col = layout.column(heading="Types")
+        self.draw_edge_type_buttons(col, lineset, "silhouette")
+        self.draw_edge_type_buttons(col, lineset, "crease")
+        self.draw_edge_type_buttons(col, lineset, "border")
+        self.draw_edge_type_buttons(col, lineset, "edge_mark")
+        self.draw_edge_type_buttons(col, lineset, "contour")
+        self.draw_edge_type_buttons(col, lineset, "external_contour")
+        self.draw_edge_type_buttons(col, lineset, "material_boundary")
+        self.draw_edge_type_buttons(col, lineset, "suggestive_contour")
+        self.draw_edge_type_buttons(col, lineset, "ridge_valley")
+
+
+class VIEWLAYER_PT_freestyle_lineset_facemarks(ViewLayerFreestyleLinesetSubPanel, Panel):
+    bl_label = "Face Marks"
+    bl_options = {'DEFAULT_CLOSED'}
+
+    def draw_header(self, context):
+        layout = self.layout
+
+        view_layer = context.view_layer
+        freestyle = view_layer.freestyle_settings
+        lineset = freestyle.linesets.active
+
+        layout.prop(lineset, "select_by_face_marks", text="")
+
+    def draw(self, context):
+        layout = self.layout
+        layout.use_property_split = True
+        layout.use_property_decorate = False
+
+        ui_factor = context.region.width / bpy.context.preferences.system.dpi
+        is_narrow = ui_factor < 3
+
+        view_layer = context.view_layer
+        freestyle = view_layer.freestyle_settings
+        lineset = freestyle.linesets.active
+
+        if lineset is None:
+            return False
+
+        layout.active = lineset.select_by_face_marks
+
+        flow = layout.column() if is_narrow else layout.row()
+        flow.prop(lineset, "face_mark_negation", expand=True, text="Negation")
+
+        flow = layout.column() if is_narrow else layout.row()
+        flow.prop(lineset, "face_mark_condition",
+                  expand=True, text="Condition")
+
+
+class VIEWLAYER_PT_freestyle_lineset_collection(ViewLayerFreestyleLinesetSubPanel, Panel):
+    bl_label = "Collection"
+    bl_options = {'DEFAULT_CLOSED'}
+
+    def draw_header(self, context):
+        layout = self.layout
+
+        view_layer = context.view_layer
+        freestyle = view_layer.freestyle_settings
+        lineset = freestyle.linesets.active
+
+        layout.prop(lineset, "select_by_collection", text="")
+
+    def draw(self, context):
+        layout = self.layout
+        layout.use_property_split = True
+        layout.use_property_decorate = False
+
+        ui_factor = context.region.width / bpy.context.preferences.system.dpi
+        is_narrow = ui_factor < 3
+
+        view_layer = context.view_layer
+        freestyle = view_layer.freestyle_settings
+        lineset = freestyle.linesets.active
+
+        if lineset is None:
+            return False
+
+        layout.active = lineset.select_by_collection
+
+        layout.row().prop(lineset, "collection", text="Freestyle Lineset Collection")
+        flow = layout.column() if is_narrow else layout.row()
+        flow.prop(lineset, "collection_negation", expand=True, text="Negation")
+
+
+# Linestyle Modifier Drawing code
+def draw_modifier_box_header(box, modifier):
+    row = box.row()
+    row.use_property_split = False
+    row.context_pointer_set("modifier", modifier)
+    if modifier.expanded:
+        icon = 'TRIA_DOWN'
+    else:
+        icon = 'TRIA_RIGHT'
+    row.prop(modifier, "expanded", text="", icon=icon, emboss=False)
+    # TODO: Use icons rather than text label, would save some room!
+    row.label(text=modifier.rna_type.name)
+    row.prop(modifier, "name", text="")
+    if modifier.use:
+        icon = 'RESTRICT_RENDER_OFF'
+    else:
+        icon = 'RESTRICT_RENDER_ON'
+    row.prop(modifier, "use", text="", icon=icon)
+    sub = row.row(align=True)
+    sub.operator("scene.freestyle_modifier_copy", icon='NONE', text="Copy")
+    sub.operator("scene.freestyle_modifier_move",
+                 icon='TRIA_UP', text="").direction = 'UP'
+    sub.operator("scene.freestyle_modifier_move",
+                 icon='TRIA_DOWN', text="").direction = 'DOWN'
+    sub.operator("scene.freestyle_modifier_remove", icon='X', text="")
+
+
+def draw_modifier_box_error(box, _modifier, message):
+    row = box.row()
+    row.label(text=message, icon='ERROR')
+
+
+def draw_modifier_common(box, modifier):
+    row = box.row()
+    row.prop(modifier, "blend", text="")
+    row.prop(modifier, "influence")
+
+
+def draw_modifier_color_ramp_common(box, modifier, has_range):
+    box.template_color_ramp(modifier, "color_ramp", expand=True)
+    if has_range:
+        row = box.row(align=True)
+        row.prop(modifier, "range_min")
+        row.prop(modifier, "range_max")
+
+
+def draw_modifier_curve_common(box, modifier, has_range, has_value):
+    row = box.row()
+    row.prop(modifier, "mapping", text="")
+    sub = row.column()
+    sub.prop(modifier, "invert")
+    if modifier.mapping == 'CURVE':
+        sub.active = False
+        box.template_curve_mapping(modifier, "curve")
+    if has_range:
+        row = box.row(align=True)
+        row.prop(modifier, "range_min")
+        row.prop(modifier, "range_max")
+    if has_value:
+        row = box.row(align=True)
+        row.prop(modifier, "value_min")
+        row.prop(modifier, "value_max")
+
+
+class VIEWLAYER_PT_freestyle_linestyle(ViewLayerFreestyleLineStyle, Panel):
     bl_label = "Freestyle Line Style"
+
+    def draw_header_preset(self, _context):
+        VIEWLAYER_PT_linestyle_presets.draw_panel_header(self.layout)
+
+    def draw(self, context):
+        layout = self.layout
+        layout.use_property_split = True
+        layout.use_property_decorate = False
+
+        view_layer = context.view_layer
+        lineset = view_layer.freestyle_settings.linesets.active
+
+        layout.active = view_layer.use_freestyle
+
+        if lineset is None:
+            return
+        linestyle = lineset.linestyle
+
+        layout.template_ID(lineset, "linestyle",
+                           new="scene.freestyle_linestyle_new")
+        if linestyle is None:
+            return
+        row = layout.row(align=True)
+        row.use_property_split = False
+
+
+class VIEWLAYER_PT_freestyle_linestyle_strokes(ViewLayerFreestyleLineStyle, Panel):
+    bl_label = "Freestyle Line Style: Strokes"
     bl_options = {'DEFAULT_CLOSED'}
-    COMPAT_ENGINES = {'BLENDER_RENDER', 'BLENDER_EEVEE', 'BLENDER_WORKBENCH'}
 
-    def draw_modifier_box_header(self, box, modifier):
-        row = box.row()
-        row.context_pointer_set("modifier", modifier)
-        if modifier.expanded:
-            icon = 'TRIA_DOWN'
-        else:
-            icon = 'TRIA_RIGHT'
-        row.prop(modifier, "expanded", text="", icon=icon, emboss=False)
-        # TODO: Use icons rather than text label, would save some room!
-        row.label(text=modifier.rna_type.name)
-        row.prop(modifier, "name", text="")
-        if modifier.use:
-            icon = 'RESTRICT_RENDER_OFF'
-        else:
-            icon = 'RESTRICT_RENDER_ON'
-        row.prop(modifier, "use", text="", icon=icon)
-        sub = row.row(align=True)
-        sub.operator("scene.freestyle_modifier_copy", icon='NONE', text="Copy")
-        sub.operator("scene.freestyle_modifier_move", icon='TRIA_UP', text="").direction = 'UP'
-        sub.operator("scene.freestyle_modifier_move", icon='TRIA_DOWN', text="").direction = 'DOWN'
-        sub.operator("scene.freestyle_modifier_remove", icon='X', text="")
-
-    def draw_modifier_box_error(self, box, _modifier, message):
-        row = box.row()
-        row.label(text=message, icon='ERROR')
-
-    def draw_modifier_common(self, box, modifier):
-        row = box.row()
-        row.prop(modifier, "blend", text="")
-        row.prop(modifier, "influence")
-
-    def draw_modifier_color_ramp_common(self, box, modifier, has_range):
-        box.template_color_ramp(modifier, "color_ramp", expand=True)
-        if has_range:
-            row = box.row(align=True)
-            row.prop(modifier, "range_min")
-            row.prop(modifier, "range_max")
-
-    def draw_modifier_curve_common(self, box, modifier, has_range, has_value):
-        row = box.row()
-        row.prop(modifier, "mapping", text="")
-        sub = row.column()
-        sub.prop(modifier, "invert")
-        if modifier.mapping == 'CURVE':
-            sub.active = False
-            box.template_curve_mapping(modifier, "curve")
-        if has_range:
-            row = box.row(align=True)
-            row.prop(modifier, "range_min")
-            row.prop(modifier, "range_max")
-        if has_value:
-            row = box.row(align=True)
-            row.prop(modifier, "value_min")
-            row.prop(modifier, "value_max")
+    def draw(self, context):
+        layout = self.layout
+        layout.use_property_split = True
+        layout.use_property_decorate = False
+
+        view_layer = context.view_layer
+        lineset = view_layer.freestyle_settings.linesets.active
+
+        layout.active = view_layer.use_freestyle
+
+        if lineset is None:
+            return
+        linestyle = lineset.linestyle
+
+        if linestyle is None:
+            return
+
+        row = layout.row(align=True)
+        row.alignment = "LEFT"
+        row.label(text=lineset.name, icon="LINE_DATA")
+        row.label(text="", icon="SMALL_TRI_RIGHT_VEC")
+        row.label(text=linestyle.name)
+
+        col = layout.column(align=True)
+        col.prop(linestyle, "caps", expand=True)
+
+
+class VIEWLAYER_PT_freestyle_linestyle_strokes_chaining(ViewLayerFreestyleLinestyleStrokesSubPanel, Panel):
+    bl_label = "Chaining"
+
+    def draw_header(self, context):
+        layout = self.layout
+
+        view_layer = context.view_layer
+        freestyle = view_layer.freestyle_settings
+        lineset = freestyle.linesets.active
+
+        linestyle = lineset.linestyle
+        layout.prop(linestyle, "use_chaining", text="")
+
+    def draw(self, context):
+        layout = self.layout
+        layout.use_property_split = True
+        layout.use_property_decorate = False
+
+        ui_factor = context.region.width / bpy.context.preferences.system.dpi
+        is_narrow = ui_factor < 3
+
+        view_layer = context.view_layer
+        lineset = view_layer.freestyle_settings.linesets.active
+        linestyle = lineset.linestyle
+
+        layout.active = linestyle.use_chaining
+
+        flow = layout.column() if is_narrow else layout.row()
+        flow.prop(linestyle, "chaining", expand=True, text="Method")
+
+        if linestyle.chaining == 'SKETCHY':
+            layout.prop(linestyle, "rounds")
+        layout.prop(linestyle, "use_same_object")
+
+
+class VIEWLAYER_PT_freestyle_linestyle_strokes_splitting(ViewLayerFreestyleLinestyleStrokesSubPanel, Panel):
+    bl_label = "Splitting"
+    bl_options = {'DEFAULT_CLOSED'}
+
+    def draw(self, context):
+        layout = self.layout
+        layout.use_property_split = True
+        layout.use_property_decorate = False
+
+        view_layer = context.view_layer
+        lineset = view_layer.freestyle_settings.linesets.active
+        linestyle = lineset.linestyle
+
+        row = layout.row(align=False, heading="Min 2D Angle")
+        row.prop(linestyle, "use_angle_min", text="")
+        sub = row.row()
+        sub.active = linestyle.use_angle_min
+        sub.prop(linestyle, "angle_min", text="")
+
+        row = layout.row(align=False, heading="Max 2D Angle")
+        row.prop(linestyle, "use_angle_max", text="")
+        sub = row.row()
+        sub.active = linestyle.use_angle_max
+        sub.prop(linestyle, "angle_max", text="")
+
+        row = layout.row(align=False, heading="2D Length")
+        row.prop(linestyle, "use_split_length", text="")
+        sub = row.row()
+        sub.active = linestyle.use_split_length
+        sub.prop(linestyle, "split_length", text="")
+
+        layout.prop(linestyle, "material_boundary")
+
+
+class VIEWLAYER_PT_freestyle_linestyle_strokes_splitting_pattern(ViewLayerFreestyleLinestyleStrokesSubPanel, Panel):
+    bl_label = "Split Pattern"
+    bl_parent_id = "VIEWLAYER_PT_freestyle_linestyle_strokes_splitting"
+    bl_options = {'DEFAULT_CLOSED'}
+
+    def draw_header(self, context):
+        layout = self.layout
+
+        view_layer = context.view_layer
+        freestyle = view_layer.freestyle_settings
+        lineset = freestyle.linesets.active
+
+        linestyle = lineset.linestyle
+        layout.prop(linestyle, "use_split_pattern", text="")
+
+    def draw(self, context):
+        layout = self.layout
+        layout.use_property_decorate = False
+
+        view_layer = context.view_layer
+        lineset = view_layer.freestyle_settings.linesets.active
+        linestyle = lineset.linestyle
+
+        layout.active = linestyle.use_split_pattern
+
+        col = layout.column(align=True)
+        col.prop(linestyle, "split_dash1", text="D1")
+        col.prop(linestyle, "split_gap1", text="G1")
+        col.prop(linestyle, "split_dash2", text="D2")
+        col.prop(linestyle, "split_gap2", text="G2")
+        col.prop(linestyle, "split_dash3", text="D3")
+        col.prop(linestyle, "split_gap3", text="G3")
+
+
+class VIEWLAYER_PT_freestyle_linestyle_strokes_sorting(ViewLayerFreestyleLinestyleStrokesSubPanel, Panel):
+    bl_label = "Sorting"
+    bl_options = {'DEFAULT_CLOSED'}
+
+    def draw_header(self, context):
+        layout = self.layout
+
+        view_layer = context.view_layer
+        freestyle = view_layer.freestyle_settings
+        lineset = freestyle.linesets.active
+
+        linestyle = lineset.linestyle
+        layout.prop(linestyle, "use_sorting", text="")
+
+    def draw(self, context):
+        layout = self.layout
+        layout.use_property_split = True
+        layout.use_property_decorate = False
+
+        ui_factor = context.region.width / bpy.context.preferences.system.dpi
+        is_narrow = ui_factor < 3
+
+        view_layer = context.view_layer
+        freestyle = view_layer.freestyle_settings
+        lineset = freestyle.linesets.active
+
+        linestyle = lineset.linestyle
+
+        layout.active = linestyle.use_sorting
+
+        layout.prop(linestyle, "sort_key")
+
+        row = layout.row()
+        row.active = linestyle.sort_key in {'DISTANCE_FROM_CAMERA',
+                                            'PROJECTED_X',
+                                            'PROJECTED_Y'}
+        row.prop(linestyle, "integration_type")
+
+        flow = layout.column() if is_narrow else layout.row()
+        flow.prop(linestyle, "sort_order", expand=True)
+
+
+class VIEWLAYER_PT_freestyle_linestyle_strokes_selection(ViewLayerFreestyleLinestyleStrokesSubPanel, Panel):
+    bl_label = "Selection"
+    bl_options = {'DEFAULT_CLOSED'}
+
+    def draw(self, context):
+        layout = self.layout
+        layout.use_property_split = True
+        layout.use_property_decorate = False
+
+        view_layer = context.view_layer
+        lineset = view_layer.freestyle_settings.linesets.active
+        linestyle = lineset.linestyle
+
+        row = layout.row(align=False, heading="Min 2D Length")
+        row.prop(linestyle, "use_length_min", text="")
+        sub = row.row()
+        sub.active = linestyle.use_length_min
+        sub.prop(linestyle, "length_min", text="")
+
+        row = layout.row(align=False, heading="Max 2D Length")
+        row.prop(linestyle, "use_length_max", text="")
+        sub = row.row()
+        sub.active = linestyle.use_length_max
+        sub.prop(linestyle, "length_max", text="")
+
+        row = layout.row(align=False, heading="Chain Count")
+        row.prop(linestyle, "use_chain_count", text="")
+        sub = row.row()
+        sub.active = linestyle.use_chain_count
+        sub.prop(linestyle, "chain_count", text="")
+
+
+class VIEWLAYER_PT_freestyle_linestyle_strokes_dashedline(ViewLayerFreestyleLinestyleStrokesSubPanel, Panel):
+    bl_label = "Dashed Line"
+    bl_options = {'DEFAULT_CLOSED'}
+
+    def draw_header(self, context):
+        layout = self.layout
+
+        view_layer = context.view_layer
+        freestyle = view_layer.freestyle_settings
+        lineset = freestyle.linesets.active
+
+        linestyle = lineset.linestyle
+        layout.prop(linestyle, "use_dashed_line", text="")
+
+    def draw(self, context):
+        layout = self.layout
+        layout.use_property_decorate = False
+
+        view_layer = context.view_layer
+        lineset = view_layer.freestyle_settings.linesets.active
+        linestyle = lineset.linestyle
+
+        layout.active = linestyle.use_dashed_line
+
+        col = layout.column(align=True)
+        col.prop(linestyle, "dash1", text="D1")
+        col.prop(linestyle, "gap1", text="G1")
+        col.prop(linestyle, "dash2", text="D2")
+        col.prop(linestyle, "gap2", text="G2")
+        col.prop(linestyle, "dash3", text="D3")
+        col.prop(linestyle, "gap3", text="G3")
+
+
+class VIEWLAYER_PT_freestyle_linestyle_color(ViewLayerFreestyleLineStyle, Panel):
+    bl_label = "Freestyle Line Style: Color"
+    bl_options = {'DEFAULT_CLOSED'}
 
     def draw_color_modifier(self, context, modifier):
         layout = self.layout
 
         col = layout.column(align=True)
-        self.draw_modifier_box_header(col.box(), modifier)
+        draw_modifier_box_header(col.box(), modifier)
         if modifier.expanded:
             box = col.box()
-            self.draw_modifier_common(box, modifier)
+            draw_modifier_common(box, modifier)
 
             if modifier.type == 'ALONG_STROKE':
-                self.draw_modifier_color_ramp_common(box, modifier, False)
+                draw_modifier_color_ramp_common(box, modifier, False)
 
             elif modifier.type == 'DISTANCE_FROM_OBJECT':
                 box.prop(modifier, "target")
-                self.draw_modifier_color_ramp_common(box, modifier, True)
+                draw_modifier_color_ramp_common(box, modifier, True)
                 prop = box.operator("scene.freestyle_fill_range_by_selection")
                 prop.type = 'COLOR'
                 prop.name = modifier.name
 
             elif modifier.type == 'DISTANCE_FROM_CAMERA':
-                self.draw_modifier_color_ramp_common(box, modifier, True)
+                draw_modifier_color_ramp_common(box, modifier, True)
                 prop = box.operator("scene.freestyle_fill_range_by_selection")
                 prop.type = 'COLOR'
                 prop.name = modifier.name
@@ -371,117 +845,191 @@ class VIEWLAYER_PT_freestyle_linestyle(ViewLayerFreestyleEditorButtonsPanel, Pan
                     sub.active = False
                     show_ramp = True
                 if show_ramp:
-                    self.draw_modifier_color_ramp_common(box, modifier, False)
+                    draw_modifier_color_ramp_common(box, modifier, False)
 
             elif modifier.type == 'TANGENT':
-                self.draw_modifier_color_ramp_common(box, modifier, False)
+                draw_modifier_color_ramp_common(box, modifier, False)
 
             elif modifier.type == 'NOISE':
-                self.draw_modifier_color_ramp_common(box, modifier, False)
+                draw_modifier_color_ramp_common(box, modifier, False)
                 row = box.row(align=False)
                 row.prop(modifier, "amplitude")
                 row.prop(modifier, "period")
                 row.prop(modifier, "seed")
 
             elif modifier.type == 'CREASE_ANGLE':
-                self.draw_modifier_color_ramp_common(box, modifier, False)
+                draw_modifier_color_ramp_common(box, modifier, False)
                 row = box.row(align=True)
                 row.prop(modifier, "angle_min")
                 row.prop(modifier, "angle_max")
 
             elif modifier.type == 'CURVATURE_3D':
-                self.draw_modifier_color_ramp_common(box, modifier, False)
+                draw_modifier_color_ramp_common(box, modifier, False)
                 row = box.row(align=True)
                 row.prop(modifier, "curvature_min")
                 row.prop(modifier, "curvature_max")
                 freestyle = context.view_layer.freestyle_settings
                 if not freestyle.use_smoothness:
                     message = "Enable Face Smoothness to use this modifier"
-                    self.draw_modifier_box_error(col.box(), modifier, message)
+                    draw_modifier_box_error(col.box(), modifier, message)
+
+    def draw(self, context):
+        layout = self.layout
+        layout.use_property_split = True
+        layout.use_property_decorate = False
+
+        view_layer = context.view_layer
+        lineset = view_layer.freestyle_settings.linesets.active
+
+        layout.active = view_layer.use_freestyle
+
+        if lineset is None:
+            return
+        linestyle = lineset.linestyle
+
+        if linestyle is None:
+            return
+
+        row = layout.row(align=True)
+        row.alignment = "LEFT"
+        row.label(text=lineset.name, icon="LINE_DATA")
+        row.label(text="", icon="SMALL_TRI_RIGHT_VEC")
+        row.label(text=linestyle.name)
+
+        col = layout.column()
+        row = col.row()
+        row.prop(linestyle, "color", text="Base Color")
+        col.label(text="Modifiers:")
+        col.operator_menu_enum(
+            "scene.freestyle_color_modifier_add", "type", text="Add Modifier")
+        for modifier in linestyle.color_modifiers:
+            self.draw_color_modifier(context, modifier)
+
+
+class VIEWLAYER_PT_freestyle_linestyle_alpha(ViewLayerFreestyleLineStyle, Panel):
+    bl_label = "Freestyle Line Style: Alpha"
+    bl_options = {'DEFAULT_CLOSED'}
 
     def draw_alpha_modifier(self, context, modifier):
         layout = self.layout
 
         col = layout.column(align=True)
-        self.draw_modifier_box_header(col.box(), modifier)
+        draw_modifier_box_header(col.box(), modifier)
         if modifier.expanded:
             box = col.box()
-            self.draw_modifier_common(box, modifier)
+            draw_modifier_common(box, modifier)
 
             if modifier.type == 'ALONG_STROKE':
-                self.draw_modifier_curve_common(box, modifier, False, False)
+                draw_modifier_curve_common(box, modifier, False, False)
 
             elif modifier.type == 'DISTANCE_FROM_OBJECT':
                 box.prop(modifier, "target")
-                self.draw_modifier_curve_common(box, modifier, True, False)
+                draw_modifier_curve_common(box, modifier, True, False)
                 prop = box.operator("scene.freestyle_fill_range_by_selection")
                 prop.type = 'ALPHA'
                 prop.name = modifier.name
 
             elif modifier.type == 'DISTANCE_FROM_CAMERA':
-                self.draw_modifier_curve_common(box, modifier, True, False)
+                draw_modifier_curve_common(box, modifier, True, False)
                 prop = box.operator("scene.freestyle_fill_range_by_selection")
                 prop.type = 'ALPHA'
                 prop.name = modifier.name
 
             elif modifier.type == 'MATERIAL':
                 box.prop(modifier, "material_attribute", text="")
-                self.draw_modifier_curve_common(box, modifier, False, False)
+                draw_modifier_curve_common(box, modifier, False, False)
 
             elif modifier.type == 'TANGENT':
-                self.draw_modifier_curve_common(box, modifier, False, False)
+                draw_modifier_curve_common(box, modifier, False, False)
 
             elif modifier.type == 'NOISE':
-                self.draw_modifier_curve_common(box, modifier, False, False)
+                draw_modifier_curve_common(box, modifier, False, False)
                 row = box.row(align=False)
                 row.prop(modifier, "amplitude")
                 row.prop(modifier, "period")
                 row.prop(modifier, "seed")
 
             elif modifier.type == 'CREASE_ANGLE':
-                self.draw_modifier_curve_common(box, modifier, False, False)
+                draw_modifier_curve_common(box, modifier, False, False)
                 row = box.row(align=True)
                 row.prop(modifier, "angle_min")
                 row.prop(modifier, "angle_max")
 
             elif modifier.type == 'CURVATURE_3D':
-                self.draw_modifier_curve_common(box, modifier, False, False)
+                draw_modifier_curve_common(box, modifier, False, False)
                 row = box.row(align=True)
                 row.prop(modifier, "curvature_min")
                 row.prop(modifier, "curvature_max")
                 freestyle = context.view_layer.freestyle_settings
                 if not freestyle.use_smoothness:
                     message = "Enable Face Smoothness to use this modifier"
-                    self.draw_modifier_box_error(col.box(), modifier, message)
+                    draw_modifier_box_error(col.box(), modifier, message)
+
+    def draw(self, context):
+        layout = self.layout
+        layout.use_property_split = True
+        layout.use_property_decorate = False
+
+        view_layer = context.view_layer
+        lineset = view_layer.freestyle_settings.linesets.active
+
+        layout.active = view_layer.use_freestyle
+
+        if lineset is None:
+            return
+        linestyle = lineset.linestyle
+
+        if linestyle is None:
+            return
+
+        row = layout.row(align=True)
+        row.alignment = "LEFT"
+        row.label(text=lineset.name, icon="LINE_DATA")
+        row.label(text="", icon="SMALL_TRI_RIGHT_VEC")
+        row.label(text=linestyle.name)
+
+        col = layout.column()
+        row = col.row()
+        row.prop(linestyle, "alpha", text="Base Transparency")
+        col.label(text="Modifiers:")
+        col.operator_menu_enum(
+            "scene.freestyle_alpha_modifier_add", "type", text="Add Modifier")
+        for modifier in linestyle.alpha_modifiers:
+            self.draw_alpha_modifier(context, modifier)
+
+
+class VIEWLAYER_PT_freestyle_linestyle_thickness(ViewLayerFreestyleLineStyle, Panel):
+    bl_label = "Freestyle Line Style: Thickness"
+    bl_options = {'DEFAULT_CLOSED'}
 
     def draw_thickness_modifier(self, context, modifier):
         layout = self.layout
 
         col = layout.column(align=True)
-        self.draw_modifier_box_header(col.box(), modifier)
+        draw_modifier_box_header(col.box(), modifier)
         if modifier.expanded:
             box = col.box()
-            self.draw_modifier_common(box, modifier)
+            draw_modifier_common(box, modifier)
 
             if modifier.type == 'ALONG_STROKE':
-                self.draw_modifier_curve_common(box, modifier, False, True)
+                draw_modifier_curve_common(box, modifier, False, True)
 
             elif modifier.type == 'DISTANCE_FROM_OBJECT':
                 box.prop(modifier, "target")
-                self.draw_modifier_curve_common(box, modifier, True, True)
+                draw_modifier_curve_common(box, modifier, True, True)
                 prop = box.operator("scene.freestyle_fill_range_by_selection")
                 prop.type = 'THICKNESS'
                 prop.name = modifier.name
 
             elif modifier.type == 'DISTANCE_FROM_CAMERA':
-                self.draw_modifier_curve_common(box, modifier, True, True)
+                draw_modifier_curve_common(box, modifier, True, True)
                 prop = box.operator("scene.freestyle_fill_range_by_selection")
                 prop.type = 'THICKNESS'
                 prop.name = modifier.name
 
             elif modifier.type == 'MATERIAL':
                 box.prop(modifier, "material_attribute", text="")
-                self.draw_modifier_curve_common(box, modifier, False, True)
+                draw_modifier_curve_common(box, modifier, False, True)
 
             elif modifier.type == 'CALLIGRAPHY':
                 box.prop(modifier, "orientation")
@@ -490,7 +1038,7 @@ class VIEWLAYER_PT_freestyle_linestyle(ViewLayerFreestyleEditorButtonsPanel, Pan
                 row.prop(modifier, "thickness_max")
 
             elif modifier.type == 'TANGENT':
-                self.draw_modifier_curve_common(box, modifier, False, False)
+                draw_modifier_curve_common(box, modifier, False, False)
                 self.mapping = 'CURVE'
                 row = box.row(align=True)
                 row.prop(modifier, "thickness_min")
@@ -505,7 +1053,7 @@ class VIEWLAYER_PT_freestyle_linestyle(ViewLayerFreestyleEditorButtonsPanel, Pan
                 row.prop(modifier, "use_asymmetric")
 
             elif modifier.type == 'CREASE_ANGLE':
-                self.draw_modifier_curve_common(box, modifier, False, False)
+                draw_modifier_curve_common(box, modifier, False, False)
                 row = box.row(align=True)
                 row.prop(modifier, "thickness_min")
                 row.prop(modifier, "thickness_max")
@@ -514,7 +1062,7 @@ class VIEWLAYER_PT_freestyle_linestyle(ViewLayerFreestyleEditorButtonsPanel, Pan
                 row.prop(modifier, "angle_max")
 
             elif modifier.type == 'CURVATURE_3D':
-                self.draw_modifier_curve_common(box, modifier, False, False)
+                draw_modifier_curve_common(box, modifier, False, False)
                 row = box.row(align=True)
                 row.prop(modifier, "thickness_min")
                 row.prop(modifier, "thickness_max")
@@ -524,13 +1072,60 @@ class VIEWLAYER_PT_freestyle_linestyle(ViewLayerFreestyleEditorButtonsPanel, Pan
                 freestyle = context.view_layer.freestyle_settings
                 if not freestyle.use_smoothness:
                     message = "Enable Face Smoothness to use this modifier"
-                    self.draw_modifier_box_error(col.box(), modifier, message)
+                    draw_modifier_box_error(col.box(), modifier, message)
+
+    def draw(self, context):
+        layout = self.layout
+        layout.use_property_split = True
+        layout.use_property_decorate = False
+
+        view_layer = context.view_layer
+        lineset = view_layer.freestyle_settings.linesets.active
+
+        layout.active = view_layer.use_freestyle
+
+        if lineset is None:
+            return
+        linestyle = lineset.linestyle
+
+        if linestyle is None:
+            return
+
+        row = layout.row(align=True)
+        row.alignment = "LEFT"
+        row.label(text=lineset.name, icon="LINE_DATA")
+        row.label(text="", icon="SMALL_TRI_RIGHT_VEC")
+        row.label(text=linestyle.name)
+
+        col = layout.column()
+        row = col.row()
+        row.prop(linestyle, "thickness", text="Base Thickness")
+        subcol = col.column()
+        subcol.active = linestyle.chaining == 'PLAIN' and linestyle.use_same_object
+        row = subcol.row()
+        row.prop(linestyle, "thickness_position", expand=False)
+
+        if linestyle.thickness_position == 'RELATIVE':
+            row = subcol.row()
+            row.prop(linestyle, "thickness_ratio")
+
+        col = layout.column()
+        col.label(text="Modifiers:")
+        col.operator_menu_enum(
+            "scene.freestyle_thickness_modifier_add", "type", text="Add Modifier")
+        for modifier in linestyle.thickness_modifiers:
+            self.draw_thickness_modifier(context, modifier)
+
+
+class VIEWLAYER_PT_freestyle_linestyle_geometry(ViewLayerFreestyleLineStyle, Panel):
+    bl_label = "Freestyle Line Style: Geometry"
+    bl_options = {'DEFAULT_CLOSED'}
 
     def draw_geometry_modifier(self, _context, modifier):
         layout = self.layout
 
         col = layout.column(align=True)
-        self.draw_modifier_box_header(col.box(), modifier)
+        draw_modifier_box_header(col.box(), modifier)
         if modifier.expanded:
             box = col.box()
 
@@ -628,6 +1223,8 @@ class VIEWLAYER_PT_freestyle_linestyle(ViewLayerFreestyleEditorButtonsPanel, Pan
 
     def draw(self, context):
         layout = self.layout
+        layout.use_property_split = True
+        layout.use_property_decorate = False
 
         view_layer = context.view_layer
         lineset = view_layer.freestyle_settings.linesets.active
@@ -638,177 +1235,60 @@ class VIEWLAYER_PT_freestyle_linestyle(ViewLayerFreestyleEditorButtonsPanel, Pan
             return
         linestyle = lineset.linestyle
 
-        layout.template_ID(lineset, "linestyle", new="scene.freestyle_linestyle_new")
         if linestyle is None:
             return
+
         row = layout.row(align=True)
-        row.prop(linestyle, "panel", expand=True)
-        if linestyle.panel == 'STROKES':
-            # Chaining
-            layout.prop(linestyle, "use_chaining", text="Chaining:")
-            split = layout.split(align=True)
-            split.active = linestyle.use_chaining
-            # First column
-            col = split.column()
-            col.active = linestyle.use_chaining
-            col.prop(linestyle, "chaining", text="")
-            if linestyle.chaining == 'SKETCHY':
-                col.prop(linestyle, "rounds")
-            # Second column
-            col = split.column()
-            col.prop(linestyle, "use_same_object")
-
-            # Splitting
-            layout.label(text="Splitting:")
-            split = layout.split(align=True)
-            # First column
-            col = split.column()
-            row = col.row(align=True)
-            row.prop(linestyle, "use_angle_min", text="")
-            sub = row.row()
-            sub.active = linestyle.use_angle_min
-            sub.prop(linestyle, "angle_min")
-            row = col.row(align=True)
-            row.prop(linestyle, "use_angle_max", text="")
-            sub = row.row()
-            sub.active = linestyle.use_angle_max
-            sub.prop(linestyle, "angle_max")
-            # Second column
-            col = split.column()
-            row = col.row(align=True)
-            row.prop(linestyle, "use_split_length", text="")
-            sub = row.row()
-            sub.active = linestyle.use_split_length
-            sub.prop(linestyle, "split_length", text="2D Length")
-            row = col.row(align=True)
-            row.prop(linestyle, "material_boundary")
-            # End of columns
-            row = layout.row(align=True)
-            row.prop(linestyle, "use_split_pattern", text="")
-            sub = row.row(align=True)
-            sub.active = linestyle.use_split_pattern
-            sub.prop(linestyle, "split_dash1", text="D1")
-            sub.prop(linestyle, "split_gap1", text="G1")
-            sub.prop(linestyle, "split_dash2", text="D2")
-            sub.prop(linestyle, "split_gap2", text="G2")
-            sub.prop(linestyle, "split_dash3", text="D3")
-            sub.prop(linestyle, "split_gap3", text="G3")
-
-            # Sorting
-            layout.prop(linestyle, "use_sorting", text="Sorting:")
-            col = layout.column()
-            col.active = linestyle.use_sorting
-            row = col.row(align=True)
-            row.prop(linestyle, "sort_key", text="")
-            sub = row.row()
-            sub.active = linestyle.sort_key in {'DISTANCE_FROM_CAMERA',
-                                                'PROJECTED_X',
-                                                'PROJECTED_Y'}
-            sub.prop(linestyle, "integration_type", text="")
-            row = col.row(align=True)
-            row.prop(linestyle, "sort_order", expand=True)
+        row.alignment = "LEFT"
+        row.label(text=lineset.name, icon="LINE_DATA")
+        row.label(text="", icon="SMALL_TRI_RIGHT_VEC")
+        row.label(text=linestyle.name)
 
-            # Selection
-            layout.label(text="Selection:")
-            split = layout.split(align=True)
-            # First column
-            col = split.column()
-            row = col.row(align=True)
-            row.prop(linestyle, "use_length_min", text="")
-            sub = row.row()
-            sub.active = linestyle.use_length_min
-            sub.prop(linestyle, "length_min")
-            row = col.row(align=True)
-            row.prop(linestyle, "use_length_max", text="")
-            sub = row.row()
-            sub.active = linestyle.use_length_max
-            sub.prop(linestyle, "length_max")
-            # Second column
-            col = split.column()
-            row = col.row(align=True)
-            row.prop(linestyle, "use_chain_count", text="")
-            sub = row.row()
-            sub.active = linestyle.use_chain_count
-            sub.prop(linestyle, "chain_count")
-
-            # Caps
-            layout.label(text="Caps:")
-            row = layout.row(align=True)
-            row.prop(linestyle, "caps", expand=True)
-
-            # Dashed lines
-            layout.prop(linestyle, "use_dashed_line", text="Dashed Line:")
-            row = layout.row(align=True)
-            row.active = linestyle.use_dashed_line
-            row.prop(linestyle, "dash1", text="D1")
-            row.prop(linestyle, "gap1", text="G1")
-            row.prop(linestyle, "dash2", text="D2")
-            row.prop(linestyle, "gap2", text="G2")
-            row.prop(linestyle, "dash3", text="D3")
-            row.prop(linestyle, "gap3", text="G3")
-
-        elif linestyle.panel == 'COLOR':
-            col = layout.column()
-            row = col.row()
-            row.label(text="Base Color:")
-            row.prop(linestyle, "color", text="")
-            col.label(text="Modifiers:")
-            col.operator_menu_enum("scene.freestyle_color_modifier_add", "type", text="Add Modifier")
-            for modifier in linestyle.color_modifiers:
-                self.draw_color_modifier(context, modifier)
-
-        elif linestyle.panel == 'ALPHA':
-            col = layout.column()
-            row = col.row()
-            row.label(text="Base Transparency:")
-            row.prop(linestyle, "alpha")
-            col.label(text="Modifiers:")
-            col.operator_menu_enum("scene.freestyle_alpha_modifier_add", "type", text="Add Modifier")
-            for modifier in linestyle.alpha_modifiers:
-                self.draw_alpha_modifier(context, modifier)
-
-        elif linestyle.panel == 'THICKNESS':
-            col = layout.column()
-            row = col.row()
-            row.label(text="Base Thickness:")
-            row.prop(linestyle, "thickness")
-            subcol = col.column()
-            subcol.active = linestyle.chaining == 'PLAIN' and linestyle.use_same_object
-            row = subcol.row()
-            row.prop(linestyle, "thickness_position", expand=True)
-            row = subcol.row()
-            row.prop(linestyle, "thickness_ratio")
-            row.active = (linestyle.thickness_position == 'RELATIVE')
-            col = layout.column()
-            col.label(text="Modifiers:")
-            col.operator_menu_enum("scene.freestyle_thickness_modifier_add", "type", text="Add Modifier")
-            for modifier in linestyle.thickness_modifiers:
-                self.draw_thickness_modifier(context, modifier)
+        col = layout.column()
+        col.label(text="Modifiers:")
+        col.operator_menu_enum(
+            "scene.freestyle_geometry_modifier_add", "type", text="Add Modifier")
+        for modifier in linestyle.geometry_modifiers:
+            self.draw_geometry_modifier(context, modifier)
 
-        elif linestyle.panel == 'GEOMETRY':
-            col = layout.column()
-            col.label(text="Modifiers:")
-            col.operator_menu_enum("scene.freestyle_geometry_modifier_add", "type", text="Add Modifier")
-            for modifier in linestyle.geometry_modifiers:
-                self.draw_geometry_modifier(context, modifier)
 
-        elif linestyle.panel == 'TEXTURE':
-            layout.separator()
+class VIEWLAYER_PT_freestyle_linestyle_texture(ViewLayerFreestyleLineStyle, Panel):
+    bl_label = "Freestyle Line Style: Texture"
+    bl_options = {'DEFAULT_CLOSED'}
 
-            row = layout.row()
-            row.prop(linestyle, "use_nodes")
-            row.prop(linestyle, "texture_spacing", text="Spacing Along Stroke")
+    def draw(self, context):
+        layout = self.layout
+        layout.use_property_split = True
+        layout.use_property_decorate = False
 
-            row = layout.row()
-            props = row.operator(
-                "wm.properties_context_change",
-                text="Go to Linestyle Textures Properties",
-                icon='TEXTURE',
-            )
-            props.context = 'TEXTURE'
+        view_layer = context.view_layer
+        lineset = view_layer.freestyle_settings.linesets.active
 
-        elif linestyle.panel == 'MISC':
-            pass
+        layout.active = view_layer.use_freestyle
+
+        if lineset is None:
+            return
+        linestyle = lineset.linestyle
+
+        if linestyle is None:
+            return
+
+        row = layout.row(align=True)
+        row.alignment = "LEFT"
+        row.label(text=lineset.name, icon="LINE_DATA")
+        row.label(text="", icon="SMALL_TRI_RIGHT_VEC")
+        row.label(text=linestyle.name)
+
+        layout.prop(linestyle, "use_nodes")
+        layout.prop(linestyle, "texture_spacing", text="Spacing Along Stroke")
+
+        row = layout.row()
+        props = row.operator(
+            "wm.properties_context_change",
+            text="Go to Linestyle Textures Properties",
+            icon='TEXTURE',
+        )
+        props.context = 'TEXTURE'
 
 
 # Material properties
@@ -846,12 +1326,29 @@ class MATERIAL_PT_freestyle_line(MaterialFreestyleButtonsPanel, Panel):
 
 
 classes = (
+    VIEWLAYER_PT_linestyle_presets,
     RENDER_PT_freestyle,
     VIEWLAYER_UL_linesets,
     RENDER_MT_lineset_context_menu,
     VIEWLAYER_PT_freestyle,
     VIEWLAYER_PT_freestyle_lineset,
+    VIEWLAYER_PT_freestyle_lineset_visibilty,
+    VIEWLAYER_PT_freestyle_lineset_edgetypes,
+    VIEWLAYER_PT_freestyle_lineset_facemarks,
+    VIEWLAYER_PT_freestyle_lineset_collection,
     VIEWLAYER_PT_freestyle_linestyle,
+    VIEWLAYER_PT_freestyle_linestyle_strokes,
+    VIEWLAYER_PT_freestyle_linestyle_strokes_chaining,
+    VIEWLAYER_PT_freestyle_linestyle_strokes_splitting,
+    VIEWLAYER_PT_freestyle_linestyle_strokes_splitting_pattern,
+    VIEWLAYER_PT_freestyle_linestyle_strokes_sorting,
+    VIEWLAYER_PT_freestyle_linestyle_strokes_selection,
+    VIEWLAYER_PT_freestyle_linestyle_strokes_dashedline,
+    VIEWLAYER_PT_freestyle_linestyle_color,
+    VIEWLAYER_PT_freestyle_linestyle_alpha,
+    VIEWLAYER_PT_freestyle_linestyle_thickness,
+    VIEWLAYER_PT_freestyle_linestyle_geometry,
+    VIEWLAYER_PT_freestyle_linestyle_texture,
     MATERIAL_PT_freestyle_line,
 )
 
diff --git a/source/blender/makesrna/intern/rna_scene.c b/source/blender/makesrna/intern/rna_scene.c
index 58a89b7ffdc..bcd7b3b00a9 100644
--- a/source/blender/makesrna/intern/rna_scene.c
+++ b/source/blender/makesrna/intern/rna_scene.c
@@ -4724,7 +4724,7 @@ void rna_def_freestyle_settings(BlenderRNA *brna)
       {FREESTYLE_QI_RANGE,
        "RANGE",
        0,
-       "QI Range",
+       "Quantitative Invisibility",
        "Select feature edges within a range of quantitative invisibility (QI) values"},
       {0, NULL, 0, NULL, NULL},
   };
